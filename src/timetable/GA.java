package timetable;

import java.io.FileNotFoundException;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class GA {
	private static short popSize;
	private static short elitismSize;
	private static byte mutationTimes;//how many times every indvi in the best (elitism) list will be mutated 
	private static List<Indvi> elitismList=new ArrayList<>();
	private static short NoMutatedExam;
	private static int generations;
	private Problem base;
	public List<Indvi> initialPopulation= new ArrayList<>();
	public List<Indvi> population= new ArrayList<>();
	public ArrayList<Integer> bestResults = new ArrayList<>();
	public ArrayList<Integer> worstResults = new ArrayList<>();
	public static short attempts =0;
	private static int maxAttempts= 10000000;
	private static byte maxRepeated=0;
	private static short counterPop=0;
	public static short counterRuns=0;
	private Scanner show=new Scanner(System.in);
	
// set methods =================================================================================================	
public static void setPopSize(short size)
{
	popSize=size;
}

public static void setGeneration(int generation)
{
	generations = generation;
}

public static void setElitismSize(short size)
{
	elitismSize=size;
}


public static void setMutationTimes(byte Times)
{
	mutationTimes=Times;
}

public static void setMaxRepeated(byte MaxRepeated)
{
	maxRepeated=MaxRepeated;
}


public static void setNoMutatedExam(short No)
{
	NoMutatedExam=No;
}


public static void incrementCounterPop()
{
	counterPop+=1;
}



public static void addElitismList(Indvi sol)
{
	elitismList.add(sol);
}

public static void removeElitismList(int index)
{
	elitismList.remove(index);
}

public void setMaxAttempts(int maxAttempts){
	this.maxAttempts = maxAttempts;
}
// get methods =================================================================================================

public static short getPopSize()
{
	return popSize;
}

public static short getElitismSize()
{
	return elitismSize;
}


public  static byte getMutationTimes()
{
	return mutationTimes;
}

public static int getNoMutatedExam()
{
	return NoMutatedExam;
}


public static byte getMaxRepeated()
{
	return maxRepeated;
}

public static short getCounterPop()
{
	return counterPop;
}


public static Indvi getElitismList(int index)
{
return 	elitismList.get(index);
}

public static List<Indvi> getAllElitismList()
{
return 	elitismList;
}


public Problem getBase() 
{
return base;	
}

// build generations =============================================================================================
public boolean run() throws FileNotFoundException, UnsupportedEncodingException{
	//Scanner d=new Scanner(System.in);
	int trial=0;
 base=new Problem((byte)8);
 short PS=base.getPeriodSpread();
 initialPopulation.clear();
 //base.print_allExamsInfo();
 short sizeFirstGeneration=50;
 boolean done=false;
	for(short i=0; i<sizeFirstGeneration;i++) {
		attempts=0;
		done=false;
		initialPopulation.add(new Indvi(base.Copy()));
		while(done==false & attempts <= maxAttempts){ 	
			if(attempts==maxAttempts)
				return true;// here true means no solution could be generated by this of algo
			attempts++;
			trial++;
			if(trial%10==0)
				PS--;
			
		
			
			//Select one of these methods ***********************************************************************************************
			
			
			//done=BuildTable.Build(initialPopulation.get(i).getPro(),PS);
			if(counterRuns<5)
			done=BuildTablebyLD.Build(initialPopulation.get(i).getPro());
			else if(counterRuns<10)
			done=BuildTablebyLWD.Build(initialPopulation.get(i).getPro());
			else if(counterRuns<15)
			done=BuildTablebyLE.Build(initialPopulation.get(i).getPro());
			else if(counterRuns<20)
			done=BuildTablebySD.Build(initialPopulation.get(i).getPro());
			else 
			done=BuildTableRandomly.Build(initialPopulation.get(i).getPro());
			//population.get(i).getPro().Print_allInformationOFSpecificPeriod(0);
			if(done==true)
			{initialPopulation.get(i).buildChrom();
			//population.get(i).printChrom();
			}
			if(done==false) {
				initialPopulation.remove(i);
				initialPopulation.add(new Indvi(base.Copy()));
			}
			else 
			{            	
				Fitness.setFit(initialPopulation.get(i));
				if(initialPopulation.get(i).getfitValue()==0)
					return true;
			}
		}
	}
	
	
	
	 orderingIncresinglyPopByfitness(initialPopulation);
	 for(short i=0;i<popSize;i++)
		 population.add(initialPopulation.get(i));
	for(short i=0;i<population.size();i++)
		population.get(i).setIDforIndiv(i);

	
	//******************to determine the size of mutation i.e mutationSize***************************************************
 NoMutatedExam=(short) Math.ceil(Math.pow(base.getPeriods().size()*base.getExams().size(),0.2));
	
	//********************************************************************************************************
 //*********************to determine how many indvi in the best (elitism) list will be mutated in the lightmutationforbest mehtod
 mutationTimes=(byte) Math.ceil(GA.getPopSize()/5.0);
// System.out.println("mutationTimes="+mutationTimes);
 //show.next();
 //******************************************************************************************************************************
 
 
 
 //********************************************************************************************************************************
	//for(int i=0;i<population.size();i++)
		//System.out.println(population.get(i).get_IDforIndvi());
	//Mutation.mutation(population.get(0), this);
	
if(attempts == maxAttempts)
	System.out.println("*** Infeasible solution***");
	 


     Fitness.setRatio(population);
     Fitness.setInterval(population);
	//***************************
	// System.out.println("Initial population");
	// printPop(population);
	// PrintSolution.printing(population.get(0).getPro());
	//****************************

//	Nextpop.computeDifferencesVSbestSolforEachIndvi(population);//preparing to build the elitism list
	//Nextpop.orderingIndividualsByDifferencesVsBest(population);//preparing to build the elitism list
	//printPop(population);
	//Nextpop.rebuild_Elitism_List(this,population);
	//for( int dd=0;dd<elitismList.size();dd++)
	//	System.out.println("the individual ("+elitismList.get(dd).get_IDforIndvi()+") is in the elitism list with fitness value"+ elitismList.get(dd).getfitValue());

	//*****************************
//	for(byte i=0;i<elitismSize;i++)
	//	elitismList.add(new Indvi(population.get(i).getPro(),  population.get(i).getfitValue(),population.get(i).getInverseFitValue(),
		//		population.get(i).getfitRatio(),population.get(i).getInterval(),population.get(i).get_IDforIndvi()));
	for(int i=0;i<generations;i++)
	{List<Indvi> temp=new ArrayList<>();
	temp.clear();
	
		temp=Nextpop.generate(population,this);
		
		population.clear();
		System.out.print("indiviuals' (Id,fitness value,selection times) of this generation("+i+")=");
		for(int j=0;j<temp.size();j++)
			{
			System.out.print("("+temp.get(j).get_IDforIndvi()+","+temp.get(j).getfitValue()+")-" );
			population.add(temp.get(j));
			}
		
		System.out.println();
		
		System.out.println("**** the next generation ******");
		Fitness.orderingIncresinglyPop(population);
		//  printPop(population);
	     
	      
		if(population.get(0).getfitValue()==0) //if the optimal solution reached
		{
			// printPop(population);
			// PrintSolution.printing(population.get(0).getPro());
			return true;
		}
		
		//show.next();
		
	}
	//******************************************
	
	// PrintSolution.printing(population.get(0).getPro()); //to print into file Solution the best sol has been reached.
	
		/*
		int sizeExamS=0;
		for(int s=0;s<population.get(0).getPro().getExams().size();s++)
			sizeExamS+=population.get(0).getPro().getExams().get(s).getSize();
		System.out.println("Size for All ExamS is ="+sizeExamS);
		
		int SizeCapcitesRommS=0;
        int SizeFreeCapcitesRommS=0;
        int NoExaminAllPeriods=0;
        int NoExamsinAllRooms=0;
        int NoExclusiveRooms=0;
		for(int p=0;p<population.get(0).getPro().getPeriods().size();p++)
		{NoExaminAllPeriods+=population.get(0).getPro().getPeriods().get(p).get_allPeriodExamS().size();
			for(int pr=0;pr<population.get(0).getPro().getPeriods().get(p).get_allperiodRoomS().size();pr++)
			{
	            if(population.get(0).getPro().getPeriods().get(p).get_allperiodRoomS().get(pr).getRoomExclusive()==true)
	            	NoExclusiveRooms++;
				SizeCapcitesRommS+=population.get(0).getPro().getPeriods().get(p).get_allperiodRoomS().get(pr).getCapacity();
				SizeFreeCapcitesRommS+=population.get(0).getPro().getPeriods().get(p).get_allperiodRoomS().get(pr).getFreeSize();
				NoExamsinAllRooms+=population.get(0).getPro().getPeriods().get(p).get_allperiodRoomS().get(pr).getRoomExams().size();
			}		
		}
		
		System.out.println("Number of Exclusive Room= "+NoExclusiveRooms);
		System.out.println("Size Capacities for All room= "+SizeCapcitesRommS);
		System.out.println("Size Free Capacities for All room= "+SizeFreeCapcitesRommS);
		System.out.println("Number of Exams in all Periods= "+NoExaminAllPeriods);
		System.out.println("Number of Exams in all rooms = "+NoExamsinAllRooms);
 */
		
		
		//PrintInfoPeriods(population.get(0));
		
		//PrintInfoPeriods(population.get(1));
		
	/*	int bestValue = Integer.MAX_VALUE;
		int worstValue = Integer.MIN_VALUE;
		for (Indvi ind : population) {
			if (ind.getfitValue() < bestValue)
				bestValue = ind.getfitValue().intValue(); 

			if (ind.getfitValue() > worstValue)
				worstValue = ind.getfitValue().intValue();

		}
		bestResults.add(bestValue);
		worstResults.add(worstValue);
	 System.out.println("Best: " + bestValue + ", Worst: "+ worstValue);
	 
		System.out.println(population.get(0).getfitValue());
	}
	
	int sum=0;
for(int i=0;i<population.get(0).getPro().getPeriods().size();i++)
	for(int j=0;j<population.get(0).getPro().getPeriods().get(i).get_allperiodRoomS().size();j++)
		sum+=population.get(0).getPro().getPeriods().get(i).get_allperiodRoomS().get(j).getRoomExams().size();
System.out.println("suuuummmmmmmmmmmmmmmmmm"+sum);
		
	XYLineChartExample.draw(bestResults, worstResults);
*/
	// Print_StandardD();



	return false;
}
//*******************************************************************************************************************************************
public static void printPop(List<Indvi> pop)
{
	for(int i=0;i<pop.size();i++)
		System.out.println(" Indvi ID#"+pop.get(i).get_IDforIndvi()+" Cost value= "+pop.get(i).getfitValue()+
		           " Inverse Cost value="+pop.get(i).getInverseFitValue()+
		           " Ratio="+ pop.get(i).getfitRatio()+
		           " Interval="+pop.get(i).getInterval());	
}
//*******************************************************************************************************************************************
public void printBestResults(){
	for (Integer d : bestResults)
		System.out.print(d + " ");
	System.out.println();
}
//*******************************************************************************************************************************************
public void printWorstResults(){
	for (Integer d : worstResults)
		System.out.print(d + " ");
	System.out.println();

}
//*******************************************************************************************************************************************
public static void PrintInfoPeriods(Indvi indvi){
	for(int i=0;i<indvi.getPro().getPeriods().size();i++)
		{
		System.out.print("**Period#("+indvi.getPro().getPeriods().get(i).getID()+"):=>>");
		for(int j=0;j<indvi.getPro().getPeriods().get(i).get_allPeriodExamS().size();j++)
		System.out.print(indvi.getPro().getPeriods().get(i).get_allPeriodExamS().get(j)+", ");
		System.out.println();
		for(int k=0;k<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().size();k++)
			{System.out.print("roomNO("+k+"):");
			  for(int n=0;n<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().size();n++)
			  System.out.print(indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().get(n).getID()+", ");
			  System.out.println();
			}	
		}
}
//********************************************************************************************************************************************
public static void PrintIndviInfo(Indvi indvi){
	System.out.print("indv_ID="+indvi.get_IDforIndvi()+"--> \n");
	for(int i=0; i<indvi.getPro().getExams().size();i++)
		System.out.println("idE="+indvi.getPro().getExams().get(i).getID()+"P="+indvi.getPro().getExams().get(i).getPeriod().getID()+"R="+indvi.getPro().getExams().get(i).getRoom().getID()+", ");
	
}

//********************************************************************************************************************************************
public  void Print_StandardD() 
{
	double average,sum=0,square=0,sd=0,size;
	for (int i=0; i<population.size();i++)
	{
		sum+=population.get(i).getfitValue();
		System.out.println("Cost value of Sol#"+i+"=="+population.get(i).getfitValue());
	}
	size=population.size();
	average=sum/size;
	
	
	for (int i=0; i<population.size();i++)
	{
	   square = square + Math.pow((population.get(i).getfitValue()-average), 2);	
	}
	
	sd=Math.sqrt(square/(size-1.0));
	System.out.println("average="+average);
	System.out.println("standardD="+sd);
	}
//***************************************************************************************************************************************



public static List<Indvi>  orderingIncresinglyPopByfitness(List<Indvi> pop)
{
boolean smaller=false;
int index=0;
	for(int i=1;i<pop.size();i++)
{
		
		index=i;
	
		for(int j=i-1;j>=0;j--)
{if(pop.get(i).getfitValue()<pop.get(j).getfitValue())
			{
	smaller=true;
			index=j;
			}

else
{	break;
}

		
}
if(smaller==true)
		{pop.add(index,pop.get(i));
		pop.remove(i+1);
		smaller=false;
}}

return pop;
}



}
