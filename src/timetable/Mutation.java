package timetable;

import java.io.FileNotFoundException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
// most important things you have to consider when applying any kind of mutation
// that the exam must be ordered increasingly based on their exam IDs 
public class Mutation {
private	static List<Exam> mutatedList=new ArrayList<>();
private static Indvi Sol;
private static Scanner show=new Scanner(System.in);
//lightMutation method move more than 2 exams
public static boolean ordinaryMutation(Indvi indvi, GA ga) throws FileNotFoundException, UnsupportedEncodingException
{//PrintInfoPeriods(indvi);

mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.





Sol=indvi; // contains the lists of 
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
List<Short> indecies=new ArrayList<>(); //stores the exam ids that have been already selected to prevent them 
Random rn = new Random(); // used to generate random numbers. 
Short index; // store random number generated by rn to select exam.
//System.out.println("GA.getNoMutatedExam()="+GA.getNoMutatedExam());
//show.next();
short noExams = (short) (rn.nextInt(GA.getNoMutatedExam())+1);// store random number generated by noExams to determine how many exams we will move (mutate) depending on maximum number of exam to be mutated
short examcounter=0; // use to count the exams to be moved

//  System.out.println("the number of exams that will be mutated in this individual number("+indvi.get_IDforIndvi()+") having fitness value =["+indvi.getfitValue()+"] is ["+ noExams+"] exams");
while(examcounter<noExams)
  {index = (short) rn.nextInt(Sol.getPro().getExams().size());// store the generated number that will be equal to particular exam Id 
   if(!indecies.contains(index)) // to ensure that an exam must will not be added to mutatedList more than once
      {indecies.add(index);// add the index of exam to the indecies list to control and prevent duplication
       mutatedList.add(Sol.getPro().getExams().get(index));//add the exam as a whole object to mutatedList list  
       e=Sol.getPro().getExams().get(index);// 'e' pointers to to the selected exam
       short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
       Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
     	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		       indecies.add(ID);//adding the coin exam to indecies list prevent this exam to reselected again because it is already selected 
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
                
    Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)
  
    short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				examcounter++;
	  }//end if ( check if the indecies list already contains the selected exam) 
  } //end while

List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
    int periodId=periodsIds.get(randomIndex);
    periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
     		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
     			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{//  System.out.println("solution after mutation*************************************************************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  Pr3intInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
				//  System.out.println("-------------------------------------------------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
        if(periodsIds.size()==0)
          {
         // System.out.println("**************************   Try agian  *************************************");
           break;	
          }
}


return false;

}






public static boolean heavyMutation(Indvi indvi, GA ga) throws FileNotFoundException, UnsupportedEncodingException
{//PrintInfoPeriods(indvi);

mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.

Sol=indvi; // contains the lists of 
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
List<Short> indecies=new ArrayList<>(); //stores the exam ids that have been already selected to prevent them 
Random rn = new Random(); // used to generate random numbers. 
Short index; // store random number generated by rn to select exam.
short noExams = (short) (rn.nextInt(ga.getNoMutatedExam())+ga.getNoMutatedExam());// store random number generated by noExams to determine how many exams we will move (mutate) depending on maximum number of exam to be mutated
short examcounter=0; // use to count the exams to be moved

//  System.out.println("the number of exams that will be mutated in this individual number("+indvi.get_IDforIndvi()+") having fitness value =["+indvi.getfitValue()+"] is ["+ noExams+"] exams");
while(examcounter<noExams)
  {index = (short) rn.nextInt(Sol.getPro().getExams().size());// store the generated number that will be equal to particular exam Id 
   if(!indecies.contains(index)) // to ensure that an exam must will not be added to mutatedList more than once
      {indecies.add(index);// add the index of exam to the indecies list to control and prevent duplication
       mutatedList.add(Sol.getPro().getExams().get(index));//add the exam as a whole object to mutatedList list  
       e=Sol.getPro().getExams().get(index);// 'e' pointers to to the selected exam
       short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
       Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
     	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		       indecies.add(ID);//adding the coin exam to indecies list prevent this exam to reselected again because it is already selected 
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
                
    Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)
  
    short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				examcounter++;
	  }//end if ( check if the indecies list already contains the selected exam) 
  } //end while

List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
    int periodId=periodsIds.get(randomIndex);
    periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
     		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
     			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{//  System.out.println("solution after mutation*************************************************************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  Pr3intInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
				 // System.out.println("---------------------------------------heavy mutation in class Mutation has been success----------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
        if(periodsIds.size()==0)
          {
          //System.out.println("**************************  heavy mutation Try agian  *************************************");
           break;	
          }
}


return false;

}




//lightMutation method move just 2 or 1 exam
public static boolean lightMutation(Indvi indvi, GA ga) throws FileNotFoundException, UnsupportedEncodingException
{//PrintInfoPeriods(indvi);

mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.

Sol=indvi; // contains the lists of 
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
List<Short> indecies=new ArrayList<>(); //stores the exam ids that have been already selected to prevent them 
Random rn = new Random(); // used to generate random numbers. 
Short index; // store random number generated by rn to select exam.
short noExams = (short) (rn.nextInt(3)+1);// store random number generated by noExams to determine how many exams we will move (mutate) depending on maximum number of exam to be mutated
short examcounter=0; // use to count the exams to be moved

//  System.out.println("the number of exams that will be mutated in this individual number("+indvi.get_IDforIndvi()+") having fitness value =["+indvi.getfitValue()+"] is ["+ noExams+"] exams");
while(examcounter<noExams)
  {index = (short) rn.nextInt(Sol.getPro().getExams().size());// store the generated number that will be equal to particular exam Id 
   if(!indecies.contains(index)) // to ensure that an exam must will not be added to mutatedList more than once
      {indecies.add(index);// add the index of exam to the indecies list to control and prevent duplication
       mutatedList.add(Sol.getPro().getExams().get(index));//add the exam as a whole object to mutatedList list  
       e=Sol.getPro().getExams().get(index);// 'e' pointers to to the selected exam
       short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
       Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
     	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		       indecies.add(ID);//adding the coin exam to indecies list prevent this exam to reselected again because it is already selected 
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
                
    Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)
  
    short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				examcounter++;
	  }//end if ( check if the indecies list already contains the selected exam) 
  } //end while

List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
    int periodId=periodsIds.get(randomIndex);
    periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
     		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
     			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{//  System.out.println("solution after mutation*************************************************************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  PrintInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
				//  System.out.println("-------------------------------------------------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
        if(periodsIds.size()==0)
          {
         // System.out.println("**************************   Try agian  *************************************");
           break;	
          }
}


return false;

}



///////////////////  period-based mutation////////////////////////////////////


public static boolean deepPeriodBasedMutation(Indvi indvi) throws FileNotFoundException, UnsupportedEncodingException
{mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.
Random rn = new Random(); // used to generate random numbers. 
Nextpop.orderingDecresinglyIndviPeriodsByPenalty(indvi.getPro().getPeriods());
short Last_index_highestPenalty=(short) Math.ceil(Math.pow(indvi.getPro().getPeriods().size(),0.20) + rn.nextInt( (int) Math.ceil(Math.pow(indvi.getPro().getPeriods().size(),0.25))));// to indicate the last index of highest penalty i.e determine the range of periods
//System.out.println("Last_index_highestPenalty="+Last_index_highestPenalty);
Sol=indvi; // contains the lists of 
short noMutatedPeriods=(short) rn.nextInt(Last_index_highestPenalty);
//System.out.println("noMutatedPeriods="+noMutatedPeriods);
short randomPeriodID=0;
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
List<Short> indecies=new ArrayList<>(); //stores the exam ids that have been already selected to prevent them 
List<Byte> IDsOfExamstoBeMutated=new ArrayList<>();
short randomref=0;
short counters=0;
List<Short> randomIndexsList=new ArrayList<>();
while(counters<noMutatedPeriods)
{ randomref=(short) rn.nextInt(Last_index_highestPenalty);
	if(!randomIndexsList.contains(randomref))
		{IDsOfExamstoBeMutated.add(Sol.getPro().getPeriods().get(randomref).getID());
	randomIndexsList.add(randomref);
	counters++;
		}
}

//for(int tt=0;tt<IDsOfExamstoBeMutated.size();tt++)
//System.out.println(IDsOfExamstoBeMutated.get(tt));
//show.next();
short index=0; // store random number generated by rn to select exam.
//short noExams = (short) ();// store random number generated by noExams to determine how many exams we will move (mutate) depending on maximum number of exam to be mutated
// use to count the exams to be moved
//  System.out.println("the number of exams that will be mutated in this individual number("+indvi.get_IDforIndvi()+") having fitness value =["+indvi.getfitValue()+"] is ["+ noExams+"] exams");
short randomIndx=0;

Nextpop.orderingIncresinglyIndviPeriodssByID(indvi.getPro().getPeriods());


while(!IDsOfExamstoBeMutated.isEmpty())
{randomIndx=(short) rn.nextInt(IDsOfExamstoBeMutated.size());
randomPeriodID=IDsOfExamstoBeMutated.get(randomIndx);
IDsOfExamstoBeMutated.remove(randomIndx);
   for(short pp=0;pp<Sol.getPro().getPeriods().get(randomPeriodID).get_allPeriodExamS().size();pp++)
      {  for(short zz=0;zz<Sol.getPro().getExams().size();zz++)
    		  if(Sol.getPro().getPeriods().get(randomPeriodID).get_allPeriodExamS().get(pp)==Sol.getPro().getExams().get(zz).getID())
    			  index=zz;
    		  
    		  
       mutatedList.add(Sol.getPro().getExams().get(index));//add the exam as a whole object to mutatedList list  
       e=Sol.getPro().getExams().get(index);// 'e' pointers to to the selected exam
       short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
       Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
     	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		       indecies.add(ID);//adding the coin exam to indecies list prevent this exam to reselected again because it is already selected 
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
                
    Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)
  
    short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				
	  }//end if ( check if the indecies list already contains the selected exam) 
      //periodcounter++;
  } //end examcounter while


List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
    int periodId=periodsIds.get(randomIndex);
    periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
     		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
     			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{//  System.out.println("solution after mutation*************************************************************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  Pr3intInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
			// System.out.println("----------------------------------- -------------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
        if(periodsIds.size()==0)
          {
         // System.out.println("**************************   Try agian  *************************************");
           break;	
          }
}


return false;

}




public static boolean periodBaesdMutation(Indvi indvi) throws FileNotFoundException, UnsupportedEncodingException
{mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.
Sol=indvi; // contains the lists of 
short noMutatedPeriods=0;
short randomPeriodID=0;
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
List<Short> indecies=new ArrayList<>(); //stores the exam ids that have been already selected to prevent them 
Random rn = new Random(); // used to generate random numbers. 

short index=0; // store random number generated by rn to select exam.
//short noExams = (short) ();// store random number generated by noExams to determine how many exams we will move (mutate) depending on maximum number of exam to be mutated
// use to count the exams to be moved
//  System.out.println("the number of exams that will be mutated in this individual number("+indvi.get_IDforIndvi()+") having fitness value =["+indvi.getfitValue()+"] is ["+ noExams+"] exams");
noMutatedPeriods=(short) rn.nextInt((int) Math.ceil(Math.pow(indvi.getPro().getPeriods().size(),0.25)));
//System.out.println("noMutatedPeriods="+noMutatedPeriods);
//show.next();
short periodcounter=0;
while(periodcounter<noMutatedPeriods)
{randomPeriodID= (short) (rn.nextInt(Sol.getPro().getPeriods().size()-Problem.periodSpread)+Problem.periodSpread);
//System.out.println("randomPeriodID="+randomPeriodID);   
for(short pp=0;pp<Sol.getPro().getPeriods().get(randomPeriodID).get_allPeriodExamS().size();pp++)
      {  for(short zz=0;zz<Sol.getPro().getExams().size();zz++)
    		  if(Sol.getPro().getPeriods().get(randomPeriodID).get_allPeriodExamS().get(pp)==Sol.getPro().getExams().get(zz).getID())
    			  index=zz;
    		  
    		  
       mutatedList.add(Sol.getPro().getExams().get(index));//add the exam as a whole object to mutatedList list  
       e=Sol.getPro().getExams().get(index);// 'e' pointers to to the selected exam
       short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
       Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
     	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		       indecies.add(ID);//adding the coin exam to indecies list prevent this exam to reselected again because it is already selected 
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
                
    Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)
  
    short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				
	  }//end if ( check if the indecies list already contains the selected exam) 
      periodcounter++;
  } //end examcounter while


List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
    int periodId=periodsIds.get(randomIndex);
    periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
     		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
     			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{//  System.out.println("solution after mutation*************************************************************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  Pr3intInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
			// System.out.println("----------------------------------- -------------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
        if(periodsIds.size()==0)
          {
         // System.out.println("**************************   Try agian  *************************************");
           break;	
          }
}


return false;

}




///////////////////////////////////////////////////////////////////////////////








//lightMutation method move just 2 or 1 exam
public static boolean deepMutation(Indvi indvi) throws FileNotFoundException, UnsupportedEncodingException
{//PrintInfoPeriods(indvi);
	//Nextpop.orderingDecresinglyIndviExamsByPenalty(indvi.getPro().getExams());
	Random rn = new Random(); // used to generate random numbers.
	List<Short> IDsOfExamstoBeMutated=new ArrayList<>();
	//******************************************************************************************************
	short Last_index_highestPenalty=(short) ( Math.ceil(Math.pow(indvi.getPro().getExams().size(),0.20))+ rn.nextInt((int) Math.ceil(Math.pow(indvi.getPro().getExams().size(),0.25))));; //change later by equation
	//System.out.println("Last_index_highestPenalty="+Last_index_highestPenalty);
	//**********************************************************************************************************
mutatedList.clear();// the list contains the exams selected randomly and will be moved randomly to another period and room.
short noExams =1;// determine how many exam will be motivated
Sol=indvi; 
Nextpop.orderingDecresinglyIndviExamsByPenalty(Sol.getPro().getExams());
short randomref=0;
List<Short> randomIndexsList=new ArrayList<>();
short counters=0;
while(counters<noExams)
{ randomref=(short) rn.nextInt(Last_index_highestPenalty);
	if(!randomIndexsList.contains(randomref))
		{IDsOfExamstoBeMutated.add(Sol.getPro().getExams().get(randomref).getID());
	randomIndexsList.add(randomref);
	counters++;
		}
}
/*
System.out.println("the number of exams to be mutated is="+noExams);
for(short p=0;p<randomIndexsList.size();p++)
	System.out.println(randomIndexsList.get(p));
show.next();
*/



Nextpop.orderingIncresinglyIndviExamsByExamID(Sol.getPro().getExams());
Exam e;//to make pointer to particular exam exam
Exam eCoin;// to make pointer to any coincidence exam
 
short ref=-1;
short realindex=-1;
short examcounter=0; // use to count the exams to be moved
while(!IDsOfExamstoBeMutated.isEmpty())
{ref=(short) rn.nextInt(IDsOfExamstoBeMutated.size());
	
	mutatedList.add(Sol.getPro().getExams().get(IDsOfExamstoBeMutated.get(ref)));//add the exam as a whole object to mutatedList list  
   
;
	e=Sol.getPro().getExams().get(IDsOfExamstoBeMutated.get(ref));// 'e' pointers to to the selected exam
     short periodID=e.getPeriod().getID();//store the "period id" of the slected exam
	   //----------adding the coincidence into mutatedList and removing them from the Sol i.e " remove it from allPeriodExamS list and from RoomExams list----------------------------------------------------------------------           
     IDsOfExamstoBeMutated.remove(ref);
     Short ID;
	   if(e.get_CoinList().size()!=0)//to move the coincidence exam(s) also if any, via adding all of them to the mutatedList
	     {for(short j=0;j<e.get_CoinList().size();j++)
	         {ID = e.get_CoinList().get(j).getID();
	          for(short r=0;r<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();r++)// search to know which room in this period (the period of the current coinExam) contains coinExam  
		         {for(short examsR=0;examsR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().size();examsR++)//check each room if it has this coin exam 
		             {if(ID==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().get(examsR).getID())//check this room has this coin exam 
		                    {
		            	     Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getRoomExams().remove(examsR);//remove the coin exam from the room
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomExclusive(false);//make the room exclusive false in case it is true
				             short newFreeSize=0;//to recalculate the room free size after removing the exam
					         newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).getFreeSize()+e.get_CoinList().get(j).getSize());//to recalculate the room free size after removing the coin exam
				             Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(r).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
					        }
   	              }
		         }
		       Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID);// now remove the coin exam from allPeriodExams list
		      
		       mutatedList.add(Sol.getPro().getExams().get(ID));//adding the coin exam to the mutatedlist to reschelduing it later with its coin exams in the same period
		     }
	    }//end if---Coincidence 
              
  Short ID_Integer= new Short( e.getID());// now the ID pointers to new exam i.e ( the actual exam that is selected randomly)

  short roomIndex=-1;// to be used to store the "index of room" that contains the selected exam... we will make search by room Id to know where this object room is stored in the roomList  
	   for(short indexR=0;indexR<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().size();indexR++)
		   if(e.getRoom().getID()==Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(indexR).getID())
		   	 roomIndex=indexR;

	Sol.getPro().getPeriods().get(periodID).get_allPeriodExamS().remove(ID_Integer);//remove the exam from allPeriodsExams list 
	for(short id=0;id<Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().size();id++)//search the exam in its room to know its index in the Roomexams list in order to remove it
	   if(Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().get(id).getID()==ID_Integer)// to determine where the exam store in the Roomexams list i.e "its index" to remove its object from the list
		  {
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getRoomExams().remove(id);//once we have known its period, its the room "roomIndex", and its location in the Roomexams list, we can remove it
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomExclusive(false);//make the room exclusive false in case it is true
		   short newFreeSize=0;//to recalculate the room free size after removing the exam
		   newFreeSize=(short) (Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).getFreeSize()+e.getSize());//to recalculate the room free size after removing the exam
		   Sol.getPro().getPeriods().get(periodID).get_allperiodRoomS().get(roomIndex).setRoomFreeSize((short) newFreeSize);//set the new free size into the room
		  }
				
	  }//end if ( check if the indecies list already contains the selected exam) 


List<Integer> periodsIds=new ArrayList<>();
for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
	periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());

//Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
while(!mutatedList.isEmpty()& periodsIds.size()>0)
{   short randomIndex = (short) rn.nextInt(periodsIds.size());
  int periodId=periodsIds.get(randomIndex);
  periodsIds.remove(randomIndex);
		if(BuildinThisPeriod(mutatedList.get(0), (byte) periodId)==true)
   		{ 
			periodsIds.clear();
			  for(short pi=0;pi<Sol.getPro().getPeriods().size();pi++)
   			periodsIds.add((int) Sol.getPro().getPeriods().get(pi).getID());
			  
			   if(mutatedList.isEmpty())
			 	{ // System.out.println("solution after mutation************************************************yesssssss*************************************************************");
				//  Print_InfoMutatedExams(noExams,mutatedListUsedForPrinting);
				//  System.out.println("Indiviual Id="+Sol.get_IDforIndvi());
				//  PrintInfoPeriods(Sol);
				//  if(CheckHardConstraints.checkAllHC(Sol.getPro())==true)
				//  {System.out.println("***feasible solution***");
				//  System.out.println("-------------------------------------------------------------------------------------------------------------");
			 	//  	}
				//  else System.out.println("***Infeasible solution***");
	        	     	
	        
			 return true;	
			    }
				}	 
	
      if(periodsIds.size()==0)
        {
       // System.out.println("**************************   Try agian  *************************************");
         break;	
        }
}


return false;

}








//****************************************************************************************************************************************************
/*public static void Print_InfoMutatedExams(int NoMut, List<Exam> muteList)
{
	System.out.println("number of exams to mutated= "+NoMut);
	for( short i=0;i<muteList.size();i++)
	System.out.println("IdE=("+muteList.get(i).getID()+"),P/R=("+muteList.get(i).getPeriod().getID()+"/"+muteList.get(i).getRoom().getID()+")");
	System.out.println();
}
*/

public static void PrintInfoPeriods(Indvi indvi)//prints the exams in each periods and also each room what exams having
     {
	    for(short i=0;i<indvi.getPro().getPeriods().size();i++)
		{
		    System.out.print("**Period#("+indvi.getPro().getPeriods().get(i).getID()+"):=>>");
		    for(short j=0;j<indvi.getPro().getPeriods().get(i).get_allPeriodExamS().size();j++)
		        System.out.print(indvi.getPro().getPeriods().get(i).get_allPeriodExamS().get(j)+", ");
		        System.out.println();
		        for(short k=0;k<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().size();k++)
			{System.out.print("roomNO("+k+"):");
			  for(short n=0;n<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().size();n++)
			  System.out.print(indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().get(n).getID()+", ");
			  System.out.println();
			}	
		}
     }


public static void PrintPeriodInfo(Indvi indvi, short i)//prints the exams in each periods and also each room what exams having
{
 
	    System.out.print("**Period#("+indvi.getPro().getPeriods().get(i).getID()+"):=>>");
	    for(short j=0;j<indvi.getPro().getPeriods().get(i).get_allPeriodExamS().size();j++)
	        System.out.print(indvi.getPro().getPeriods().get(i).get_allPeriodExamS().get(j)+", ");
	        System.out.println();
	        for(short k=0;k<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().size();k++)
		{System.out.print("roomNO("+k+"):");
		  for(short n=0;n<indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().size();n++)
		  System.out.print(indvi.getPro().getPeriods().get(i).get_allperiodRoomS().get(k).getRoomExams().get(n).getID()+", ");
		  System.out.println();
		}	
	}



//******* rescheduling an exam to another period and may another room *********************************************************************************************************************************


public static boolean BuildinThisPeriod(Exam e, byte Pi){
if(e.coin.size()!=0)
	{if(midPs_checkCoincidence(e,Pi)==true)
	return true;
	else
		return false;
	}
else if( midPs_checkDuration(e,Pi)==true & midPs_checkConflict(e,Pi)==false 
		& midPs_checkExclusion(e,Pi)==false & midPs_checkAfter(e,Pi)==true & midPs_checkBefore(e,Pi)==true )
	{if(midPs_scheduleInRoom(e,Pi)==true)
	{return true;}
	}

	return false;
}
//************************for mid Periods --- checking Period duration**************************************************************

public static boolean midPs_checkDuration(Exam e, byte Pi)
{
if(e.getduration()<= Sol.getPro().getPeriods().get(Pi).getDuration())
return true;// means this period can be used to schedule this exam
else
return false;
}
//************************for midPeriods --- checkExamsConflict************************************************************************

public static boolean midPs_checkConflict(Exam e, byte Pi)
{
for(short i=0;i<e.ConflictWith.size();i++)
{
if(Sol.getPro().getPeriods().get(Pi).get_allPeriodExamS().contains(e.ConflictWith.get(i)))
	{
	//System.out.println("conflict with"+e.getID()+" with "+e.ConflictWith.get(i));
return true;}// means there is conflict
}	return false;// means no conflict

}
//************************for midPeriods --- checkExclusion************************************************************************

public static boolean midPs_checkExclusion(Exam e, byte Pi)
{
for(byte i=0; i<e.exclusion.size();i++)
if(Sol.getPro().getPeriods().get(Pi).get_allPeriodExamS().contains(e.exclusion.get(i).getID()))
	return true;
	
return false;
}
//***************************************************************************************************************

public static boolean midPs_checkBefore(Exam e, short Pi){

for(short i=0;i<e.before.size();i++)
	{


	{for(short j=0;j<=Pi;j++)
		{if(Sol.getPro().getPeriods().get(j).get_allPeriodExamS().contains(e.before.get(i).getID()))
			{//System.out.println("DDDDDDDDDDDDDDDDDDsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD");
			return false;}
		}
		
		}}
//System.out.println("DDDDDDDDDDDDDDDDDDsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD");
return true;
}

//***********






//*******if exam afterList has exams-->check if all before exams are scheduled***********************************************************
public static boolean midPs_checkAfter(Exam e, byte Pi){
	 boolean scheduled=false;
	//if(e.getID()==28)
		//System.out.println("Exam 28"+e.get_afterList().get(0).getID());
		for(short i=0;i<e.after.size();i++)
			{for(short j=0;j<Pi;j++)
				{if(Sol.getPro().getPeriods().get(j).get_allPeriodExamS().contains(e.after.get(i).getID()))
				{
					scheduled=true;
					break;
				}
				
				}
			if(scheduled==false)
				{//System.out.println("aftttttttttttttter");
				//if(e.getID()==28)
					//System.out.println("Exam 28"+e.get_afterList().get(0).getID());
				return false;
				}
			else
				scheduled=false;
			}
		
	return true;

	
}
//******if exam coincidence has exams--> check if all its all coincidence exams can be scheduled in this period**************************************************************************
public static boolean midPs_checkCoincidence(Exam e, byte Pi){
if(midPs_checkDuration(e,Pi)==false | midPs_checkConflict(e,Pi)==true
		   | midPs_checkExclusion(e,Pi)==true | midPs_checkAfter(e,Pi)==false | midPs_checkBefore(e,Pi)==false)
			return false;	
for(byte i=0;i<e.coin.size();i++)
if(midPs_checkDuration(e.coin.get(i),Pi)==false | midPs_checkConflict(e.coin.get(i),Pi)==true
| midPs_checkExclusion(e.coin.get(i),Pi)==true | midPs_checkAfter(e.coin.get(i),Pi)==false |  midPs_checkBefore(e.coin.get(i),Pi)==false)
return false;			

List<ItcRoom>AlltempRooms=new ArrayList<>();
AlltempRooms.clear();
for(byte i=0;i<Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().size();i++)
{	ItcRoom tempRoom=new ItcRoom();
tempRoom.setRoomID(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getID());
tempRoom.setRoomCapacity(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getCapacity());
tempRoom.setRoomPenalty(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getPenalty());
tempRoom.setRoomFreeSize(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getFreeSize());
tempRoom.setRoomExclusive(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getRoomExclusive());

for(short j=0;j<Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getRoomExams().size();j++)
	tempRoom.add_roomExamS(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getRoomExams().get(j));

AlltempRooms.add(tempRoom);
}



if(mid_CheckProomsForCoinExams(AlltempRooms,e)==false)//first of all, check the the Exam before its Coin Exams
{
return false;
}

//means the Exam can be scheduled in this period rooms and we will check its Coin Exams

for(byte i=0;i<e.coin.size();i++)// check its Coin Exams
{
if(mid_CheckProomsForCoinExams(AlltempRooms,e.coin.get(i))==false)
	{return false;}
}


//real scheduling 
midPs_scheduleInRoom(e,Pi);

for(short i=0;i<e.coin.size();i++)
{ for(short j=0;j<Sol.getPro().getExams().size();j++)
	if(e.coin.get(i).getID()==Sol.getPro().getExams().get(j).getID())
		midPs_scheduleInRoom(Sol.getPro().getExams().get(j),Pi);
	

	
}
return true;
}

//check if there is any room can contain this exam, if any, then schedule this exam in this room for this Period*******************************************************
public static boolean midPs_scheduleInRoom(Exam e, byte Pi)
{ 
for(byte i=0;i<Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().size();i++)
{ 
      if(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getRoomExams().size()==0)
         { if(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getFreeSize()>=e.getSize()) 
               { Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).add_roomExamS(e);
                 Sol.getPro().getPeriods().get(Pi).add_periodExamS(e.getID());
                 if(e.getRoomExclusive()==true)
                    Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).setRoomExclusive(true);
                 e.setPeroid(Sol.getPro().getPeriods().get(Pi));
    	         e.setRoom(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i));
    	         deleteExam(e.getID());
    	         return true;}}
             
        else if(e.getRoomExclusive()==false 
        	    & Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getFreeSize()>=e.getSize()
        	    & Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).getRoomExclusive()==false)
        		{ Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i).add_roomExamS(e);
                  Sol.getPro().getPeriods().get(Pi).add_periodExamS(e.getID());
                  e.setPeroid(Sol.getPro().getPeriods().get(Pi));
     	          e.setRoom(Sol.getPro().getPeriods().get(Pi).get_allperiodRoomS().get(i));
     	         deleteExam(e.getID());
     	          return true;
        		}
	  
	 
}
	
return false;
	
}


//***********check if all Coincidence Exams of this Exam can be scheduled in this Period Rooms******************
public static boolean mid_CheckProomsForCoinExams(List<ItcRoom> rooms, Exam e)
{
for(byte i=0;i<rooms.size();i++)
{ 
      if(rooms.get(i).getRoomExams().size()==0)
         { if(rooms.get(i).getFreeSize()>=e.getSize()) 
               { rooms.get(i).add_roomExamS(e);
                
                 if(e.getRoomExclusive()==true)
                   rooms.get(i).setRoomExclusive(true);
                   return true;}}
             
        else if(e.getRoomExclusive()==false 
        	    & rooms.get(i).getFreeSize()>=e.getSize()
        	    & rooms.get(i).getRoomExclusive()==false)
        		{ rooms.get(i).add_roomExamS(e);
                  
     	          return true;
        		}
	  
	 
}
	
return false;}

//*******************delete exam from all Lists by Sent Exam Id *************************************************
public static void deleteExam(short IdExam){

	
	for(short i=0;i<mutatedList.size();i++)
	{
		if(mutatedList.get(i).getID()==IdExam)
			mutatedList.remove(i);
	}
	
}





}